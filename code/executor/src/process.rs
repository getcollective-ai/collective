use anyhow::bail;
use async_trait::async_trait;
use futures::StreamExt;
use protocol::{client::Client, server, ClientPacket, Packet, ServerPacket};
use tokio::net::TcpStream;
use tokio_tungstenite::WebSocketStream;
use tracing::info;

use crate::{
    process::{question::QAndA, reader::Reader, writer::Writer},
    Comm, Executor,
};

mod question;
mod reader;
mod writer;

pub struct WebSocketComm {
    reader: Reader,
    writer: Writer,
}

impl WebSocketComm {
    pub fn new(socket: WebSocketStream<TcpStream>) -> Self {
        let (writer, reader) = socket.split();
        Self {
            reader: reader.into(),
            writer: writer.into(),
        }
    }
}

#[async_trait]
impl Comm for WebSocketComm {
    async fn send(&mut self, packet: ServerPacket) -> anyhow::Result<()> {
        self.writer.write(packet).await
    }

    async fn recv(&mut self) -> anyhow::Result<ClientPacket> {
        self.reader.read().await
    }
}

pub struct Process<C> {
    executor: Executor,
    q_and_a: Option<QAndA>,
    comm: C,
}

impl<C: Comm> Process<C> {
    pub fn new(executor: Executor, comm: C) -> Self {
        Self {
            executor,
            comm,
            q_and_a: None,
        }
    }
}

impl<C: Comm + Send> Process<C> {
    async fn process_packet(&mut self, packet: Packet<Client>) -> anyhow::Result<()> {
        match packet.data {
            // we are getting an instruction from the frontend
            // - This is the first packet we get from the frontend
            // - This defines the purpose of a [`QAndA`] session
            // - This is the first message sent from `frontend-cli`
            // - For instance if we are building a calculator, the instruction would be "Build a
            //   calculator"
            // - Questions regarding the instruction are generated by GPT4 and sent back to the
            //   frontend via the [`server::Question`] packet
            Client::Instruction { instruction } => {
                info!("Instruction: {}", instruction);

                let mut q_and_a = QAndA::new(self.executor.clone(), instruction);

                // get stream of Result<String> from chat GPT
                let mut question_stream = q_and_a.gen_question().await?.enumerate();
                let mut question = String::new();

                // loop over stream of words (String),
                // and append them to `question`
                //
                // each word will be sent as a packet to
                // the frontend
                loop {
                    match question_stream.next().await {
                        Some((i, word)) => {
                            let word = word?;
                            question.push_str(&word);
                            let is_first_word = i == 0;
                            // send a packet that will be handled by frontend-cli/app.rs
                            self.comm
                                .send(Packet::server(server::Question {
                                    question: word,
                                    is_first_word,
                                    is_last_word: false,
                                }))
                                .await?;
                        }
                        None => {
                            self.comm
                                .send(Packet::server(server::Question {
                                    question: String::new(),
                                    is_first_word: false,
                                    is_last_word: true,
                                }))
                                .await?;
                            break;
                        }
                    }
                }

                // after getting all of the stream of words appended
                // to `question`, making it a full question,
                // push the sentence into the Vec
                q_and_a.add_question(question);
                self.q_and_a = Some(q_and_a);
            }
            // from the second prompt onwards, this Event
            // will be used to continue the qa session
            Client::Answer { answer } => {
                let Some(q_and_a) = self.q_and_a.as_mut() else {
                    bail!("No question to answer");
                };

                info!("Answer: {}", answer);

                q_and_a.answer(answer);

                let mut question = String::new();
                let mut word_stream = q_and_a.gen_question().await?.enumerate();

                // loop over stream of words (String),
                // and append them to `question`
                //
                // each word will be sent as a packet to
                // the frontend
                loop {
                    match word_stream.next().await {
                        Some((i, word)) => {
                            let word = word?;
                            let is_first_word = i == 0;
                            question.push_str(&word);
                            // send a packet that will be handled by frontend-cli/app.rs
                            self.comm
                                .send(Packet::server(server::Question {
                                    question: word,
                                    is_first_word,
                                    is_last_word: false,
                                }))
                                .await?;
                        }
                        None => {
                            self.comm
                                .send(Packet::server(server::Question {
                                    question: String::new(),
                                    is_first_word: false,
                                    is_last_word: true,
                                }))
                                .await?;
                            break;
                        }
                    }
                }

                info!("Question: {}", question);
                q_and_a.add_question(question);
            }
        }
        Ok(())
    }

    pub async fn run(mut self) -> anyhow::Result<()> {
        loop {
            let packet = self.comm.recv().await?;
            self.process_packet(packet).await?;
        }
    }
}
